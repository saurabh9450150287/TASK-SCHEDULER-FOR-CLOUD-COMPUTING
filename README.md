# TASK SCHEDULER FOR CLOUD COMPUTING
 A task scheduler that schedules the tasks for their execution on a cloud platform in order to maximize the efficiency.

## Description
The task scheduling problem can be viewed as the finding or searching an optimal mapping/assignment of set of subtasks of different tasks over the available set of resources (processors/computer machines) so that we can achieve the desired goals for tasks.In this project we will be using HEFT algorithm to do this.

## HEFT Algorithm
 Heterogeneous Earliest Finish Time (or HEFT) is a heuristic to schedule a set of dependent tasks onto a network of heterogenous workers taking communication time into account.For inputs HEFT takes a set of tasks, represented as a directed acyclic graph, a set of workers, the times to execute each task on each worker, and the times to communicate the results from each job to each of its children between each pair of workers. It descends from list scheduling algorithms.<br />The HEFT algorithm is an effective solution for the DAG scheduling problem on heterogeneous systems because of its robust performance,low running time, and the ability to give stable performance over a wide range of graph structures. The limitation of HEFT algorithm is that it uses techniques that are all static approaches of the mapping problem that assume static conditions for a given period of time and also in complex situations it can easily fail to find the optimal scheduling.

### Algorithm
1.  compute the average execution time for each task t
1.  compute the average data transfer time between tasks and their successors
1.  compute rank value for each task
1.  sort the tasks in a scheduling list Q by decreasing order of task rank
value
1. while Q is not empty do
1. t remove the first task from Q
1. r find a resource which can complete t as earliest time
1. schedule t to r.
1. end while

## Testing
Since for testing our algorithm we need lot of graphs . So it becomes
very difficult to generate these graphs manually . So , we have
implemented a random graph generator which does this job for us . It
is capable of generating both type of inputs mentioned above.
 ### Random Graph Generator :
Our random graph generator requires the following input parameters :
1. Number of tasks in the graph, (N).
1. Shape parameter of the graph, ( &alpha; ). We assume that the height
(depth) of a DAG is randomly generated from a uniform distribution
with a mean value equal to sqrt(N)/&alpha; (The height is equal to the smallest
integral value not less than the real value generated randomly.) The
width for each level is randomly selected from a uniform distribution
with mean equal to a &alpha; * sqrt(N) A dense graph (a shorter graph with
high parallelism) can be generated by selecting &alpha; >> 1.0; if &alpha; << 1.0,
it will generate a longer graph with a low parallelism degree.
1. Out degree of a node, (out degree).
1. Communication to computation ratio, (CCR). It is the ratio of the average
communication cost to the average computation cost. If a DAGâ€™s
CCR value is very low, it can be considered as a computation-intensive
application.
1. Range percentage of computation costs on processors, (&beta;). It is
basically the heterogeneity factor for processor speeds. AThe average computation cost of each task n(i) in the
graph, i.e., avge(w(i)) , is selected randomly from a uniform distribution
with range [0,2x(wDAG)], where wDAG is the average computation
cost of the given graph, which is set randomly in the algorithm.
Then, the computation cost of each task ni on each processor pi in the
system is randomly set from the following range: <br />
avg(w(i)) * {1-0.5*&beta;} <= w(i,j) <= avg(w(i)) * {1+0.5*&beta;}

## Screenshots
### INPUT

![image]( https://user-images.githubusercontent.com/43703209/89745925-5f005280-dad4-11ea-9cca-564cdd609def.png )

### OUTPUT

![image](https://user-images.githubusercontent.com/43703209/89745946-7b03f400-dad4-11ea-8727-a9f402893e70.png)

